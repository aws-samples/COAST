AWSTemplateFormatVersion: 2010-09-09

Parameters:
  CreateCURReport:
    Type: String
    Default: 'true'
    Description: Choose whether to create a new CUR. Select `true` to create a new CUR in the us-east-1 region.
    AllowedValues:
      - 'true'
      - 'false'
  CURReportName:
    Type: String
    Description: Name of the new CUR or the existing CUR which you would like to use as the data source for the dashboards.
  CURReportPrefixName:
    Type: String
    Description: Enter the new CUR report path prefix or report path prefix value of the existing CUR.
  CURDataBucketName:
    Type: String
    Description: Name of existing CUR S3 bucket. Only needed if `CreateCURReport` is `false`.
  GrafanaDashboardTemplateURL:
    Type: String
    Default: https://github.com/aws-observability/observability-best-practices/raw/main/sandbox/cure-grafana-dashboard/AmazonManagedGrafanaCUREDashboard.json
    Description: URL of Grafana Dashboard to be imported. DON'T CHANGE unless you have forked this repository.
    AllowedPattern: 'https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&\/\/=]*).json'

Conditions:
  CreateCURReport:
    Fn::Equals:
      - !Ref CreateCURReport
      - 'true'
  
Resources:

  COASTNotificationsTopic:
    Type: 'AWS::SNS::Topic'
  
  CURDataBucket:
    Type: AWS::S3::Bucket
    DeletionPolicy: Retain
    UpdateReplacePolicy: Retain
    Condition: CreateCURReport
    Properties:
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      AccessControl: BucketOwnerFullControl
      OwnershipControls:
        Rules:
          - ObjectOwnership: BucketOwnerEnforced
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      VersioningConfiguration:
        Status: Enabled
      LifecycleConfiguration:
        Rules:
          - Id: Object&Version Expiration
            Status: Enabled
            NoncurrentVersionExpirationInDays: 32 
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: 'W35'
            reason: "Data buckets would generate too much logs"

  CURDataBucketPolicy:
    Type: 'AWS::S3::BucketPolicy'
    DeletionPolicy: Retain
    UpdateReplacePolicy: Delete
    Condition: CreateCURReport
    Properties:
      Bucket: !Ref CURDataBucket
      PolicyDocument:
        Id: CrossAccessPolicy
        Version: "2012-10-17"
        Statement:
          - Sid: AllowTLS12Only
            Effect: Deny
            Principal: "*"
            Action: s3:*
            Resource:
              - Fn::Sub: 'arn:${AWS::Partition}:s3:::${CURDataBucket}'
              - Fn::Sub: 'arn:${AWS::Partition}:s3:::${CURDataBucket}/*'
            Condition:
              NumericLessThan:
                s3:TlsVersion: 1.2
          - Sid: AllowOnlyHTTPS
            Effect: Deny
            Principal: "*"
            Action: s3:*
            Resource:
              - Fn::Sub: 'arn:${AWS::Partition}:s3:::${CURDataBucket}'
              - Fn::Sub: 'arn:${AWS::Partition}:s3:::${CURDataBucket}/*'
            Condition:
              Bool:
                aws:SecureTransport: false
          - Sid: AllowReadBilling
            Effect: Allow
            Principal:
              Service: billingreports.amazonaws.com
            Action:
              - s3:GetBucketAcl
              - s3:GetBucketPolicy
            Resource:
              - Fn::Sub: 'arn:${AWS::Partition}:s3:::${CURDataBucket}'
              - Fn::Sub: 'arn:${AWS::Partition}:s3:::${CURDataBucket}/*'
          - Sid: AllowWriteBilling
            Effect: Allow
            Principal:
              Service: billingreports.amazonaws.com
            Action:
              - s3:PutObject
            Resource:
              - Fn::Sub: 'arn:${AWS::Partition}:s3:::${CURDataBucket}/*'
          - Sid: AllowReplicationWrite
            Effect: Allow
            Principal:
              AWS: !Ref AWS::AccountId
            Action:
              - s3:ReplicateDelete
              - s3:ReplicateObject
            Resource:
              - Fn::Sub: 'arn:${AWS::Partition}:s3:::${CURDataBucket}/*'
          - Sid: AllowReplicationRead
            Effect: Allow
            Principal:
              AWS: !Ref AWS::AccountId
            Action:
              - s3:ListBucket
              - s3:ListBucketVersions
              - s3:GetBucketVersioning
              - s3:PutBucketVersioning
            Resource:
              - Fn::Sub: 'arn:${AWS::Partition}:s3:::${CURDataBucket}'
  
  CURReport:
    Type: AWS::CUR::ReportDefinition
    Condition: CreateCURReport
    Properties: 
      AdditionalArtifacts: 
        - ATHENA
      AdditionalSchemaElements: 
        - RESOURCES
      Compression: Parquet
      Format: Parquet
      ReportName: !Ref AWS::StackName
      S3Bucket: !Ref CURDataBucket
      S3Prefix: !Ref CURReportPrefixName
      S3Region: !Ref AWS::Region
      TimeUnit: HOURLY
      RefreshClosedReports: True
      ReportVersioning: OVERWRITE_REPORT
    DependsOn:
      - CURDataBucketPolicy

  AWSCURDatabase:
    Type: 'AWS::Glue::Database'
    Properties:
      DatabaseInput:
        Description: !Sub "${AWS::StackName} COAST database"
      CatalogId: !Ref AWS::AccountId

  AWSCURCrawlerComponentFunction:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - glue.amazonaws.com
            Action:
              - 'sts:AssumeRole'
      Path: /
      ManagedPolicyArns:
        - !Sub 'arn:${AWS::Partition}:iam::aws:policy/service-role/AWSGlueServiceRole'
      Policies:
        - PolicyName: AWSCURCrawlerComponentFunction
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - 'logs:CreateLogGroup'
                  - 'logs:CreateLogStream'
                  - 'logs:PutLogEvents'
                Resource: !Sub 'arn:${AWS::Partition}:logs:*:*:*'
              - Effect: Allow
                Action:
                  - 'glue:UpdateDatabase'
                  - 'glue:UpdatePartition'
                  - 'glue:CreateTable'
                  - 'glue:UpdateTable'
                  - 'glue:ImportCatalogToGlue'
                Resource:
                  - !Sub 'arn:aws:glue:${AWS::Region}:${AWS::AccountId}:catalog'
                  - !Sub 'arn:aws:glue:${AWS::Region}:${AWS::AccountId}:database/${AWSCURDatabase}'
                  - !Sub 'arn:aws:glue:${AWS::Region}:${AWS::AccountId}:table/${AWSCURDatabase}/*'
              - Effect: Allow
                Action:
                  - 's3:GetObject'
                  - 's3:PutObject'
                Resource:
                  Fn::If:
                    - CreateCURReport
                    - !Sub 'arn:${AWS::Partition}:s3:::${CURDataBucket}/${CURReportPrefixName}/${CURReport}/${CURReport}*'
                    - !Sub 'arn:${AWS::Partition}:s3:::${CURDataBucketName}/${CURReportPrefixName}/${CURReportName}/${CURReportName}*'
        - PolicyName: AWSCURKMSDecryption
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - 'kms:Decrypt'
                Resource: '*'
       
  AWSCURCrawlerLambdaExecutor:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - 'sts:AssumeRole'
      Path: /
      Policies:
        - PolicyName: AWSCURCrawlerLambdaExecutor
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - 'logs:CreateLogGroup'
                  - 'logs:CreateLogStream'
                  - 'logs:PutLogEvents'
                Resource: !Sub 'arn:${AWS::Partition}:logs:*:*:*'
              - Effect: Allow
                Action:
                  - 'glue:StartCrawler'
                Resource: !Sub 'arn:aws:glue:${AWS::Region}:${AWS::AccountId}:crawler/${AWSCURCrawler}'
              - Effect: Allow
                Action:
                  - 'sns:Publish'
                Resource: !Ref COASTNotificationsTopic
       
  AWSCURCrawler:
    Type: 'AWS::Glue::Crawler'
    DependsOn:
      - AWSCURDatabase
      - AWSCURCrawlerComponentFunction
    Properties:
      Name: !Sub AWSCURCrawler-${AWS::StackName}
      Description: A recurring crawler that keeps your CUR table in Athena up-to-date.
      Role: !GetAtt AWSCURCrawlerComponentFunction.Arn
      DatabaseName: !Ref AWSCURDatabase
      Targets:
        S3Targets:
          - Path:
              Fn::If:
                - CreateCURReport
                - !Sub 's3://${CURDataBucket}/${CURReportPrefixName}/${CURReport}/${CURReport}'
                - !Sub 's3://${CURDataBucketName}/${CURReportPrefixName}/${CURReportName}/${CURReportName}'
            Exclusions:
              - '**.json'
              - '**.yml'
              - '**.sql'
              - '**.csv'
              - '**.gz'
              - '**.zip'
      SchemaChangePolicy:
        UpdateBehavior: UPDATE_IN_DATABASE
        DeleteBehavior: DELETE_FROM_DATABASE
       
  AWSCURInitializer:
    Type: 'AWS::Lambda::Function'
    DependsOn: AWSCURCrawler
    Properties:
      Code:
        ZipFile: !Sub >
          const AWS = require('aws-sdk');
          const response = require('./cfn-response');
          exports.handler = function(event, context, callback) {
            if (event.RequestType === 'Delete') {
              response.send(event, context, response.SUCCESS);
            } else {
              const glue = new AWS.Glue();
              glue.startCrawler({ Name: '${AWSCURCrawler}' }, function(err, data) {
                if (err) {
                  const responseData = JSON.parse(this.httpResponse.body);
                  if (responseData['__type'] == 'CrawlerRunningException') {
                    callback(null, responseData.Message);
                  } else {
                    const responseString = JSON.stringify(responseData);
                    if (event.ResponseURL) {
                      response.send(event, context, response.FAILED,{ msg: responseString });
                    } else {
                      callback(responseString);
                    }
                  }
                }
                else {
                  if (event.ResponseURL) {
                    response.send(event, context, response.SUCCESS);
                  } else {
                    callback(null, response.SUCCESS);
                  }
                }
              });
            }
          };
      Handler: 'index.handler'
      Timeout: 30
      Runtime: nodejs16.x
      ReservedConcurrentExecutions: 1
      Role: !GetAtt AWSCURCrawlerLambdaExecutor.Arn
     
  AWSStartCURCrawler:
    Type: 'Custom::AWSStartCURCrawler'
    Properties:
      ServiceToken: !GetAtt AWSCURInitializer.Arn
     
  AWSS3CUREventLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: 'lambda:InvokeFunction'
      FunctionName: !GetAtt AWSCURInitializer.Arn
      Principal: 's3.amazonaws.com'
      SourceAccount: !Ref AWS::AccountId
      SourceArn: !If
        - CreateCURReport
        - !Sub 'arn:${AWS::Partition}:s3:::${CURDataBucket}'
        - !Sub 'arn:${AWS::Partition}:s3:::${CURDataBucketName}'
     
  AWSS3CURLambdaExecutor:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - 'sts:AssumeRole'
      Path: /
      Policies:
        - PolicyName: AWSS3CURLambdaExecutor
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - 'logs:CreateLogGroup'
                  - 'logs:CreateLogStream'
                  - 'logs:PutLogEvents'
                Resource: !Sub 'arn:${AWS::Partition}:logs:*:*:*'
              - Effect: Allow
                Action:
                  - 's3:PutBucketNotification'
                Resource: !If
                  - CreateCURReport
                  - !Sub 'arn:${AWS::Partition}:s3:::${CURDataBucket}'
                  - !Sub 'arn:${AWS::Partition}:s3:::${CURDataBucketName}'
       
  AWSS3CURNotification:
    Type: 'AWS::Lambda::Function'
    DependsOn:
    - AWSCURInitializer
    - AWSS3CUREventLambdaPermission
    - AWSS3CURLambdaExecutor
    Properties:
      Code:
        ZipFile: >
          const AWS = require('aws-sdk');
          const response = require('./cfn-response');
          exports.handler = function(event, context, callback) {
            const s3 = new AWS.S3();
            const putConfigRequest = function(notificationConfiguration) {
              return new Promise(function(resolve, reject) {
                s3.putBucketNotificationConfiguration({
                  Bucket: event.ResourceProperties.BucketName,
                  NotificationConfiguration: notificationConfiguration
                }, function(err, data) {
                  if (err) reject({ msg: this.httpResponse.body.toString(), error: err, data: data });
                  else resolve(data);
                });
              });
            };
            const newNotificationConfig = {};
            if (event.RequestType !== 'Delete') {
              newNotificationConfig.LambdaFunctionConfigurations = [{
                Events: [ 's3:ObjectCreated:*' ],
                LambdaFunctionArn: event.ResourceProperties.TargetLambdaArn || 'missing arn',
                Filter: { Key: { FilterRules: [ { Name: 'prefix', Value: event.ResourceProperties.ReportKey } ] } }
              }];
            }
            putConfigRequest(newNotificationConfig).then(function(result) {
              response.send(event, context, response.SUCCESS, result);
              callback(null, result);
            }).catch(function(error) {
              response.send(event, context, response.FAILED, error);
              console.log(error);
              callback(error);
            });
          };
      Handler: 'index.handler'
      Timeout: 30
      Runtime: nodejs16.x
      ReservedConcurrentExecutions: 1
      Role: !GetAtt AWSS3CURLambdaExecutor.Arn

  AWSPutS3CURNotification:
    Type: 'Custom::AWSPutS3CURNotification'
    Properties:
      ServiceToken: !GetAtt AWSS3CURNotification.Arn
      TargetLambdaArn: !GetAtt AWSCURInitializer.Arn
      BucketName: !If
        - CreateCURReport
        - !Sub '${CURDataBucket}'
        - !Sub '${CURDataBucketName}'
      ReportKey: !If
        - CreateCURReport
        - !Sub '${CURReportPrefixName}/${CURReport}/${CURReport}'
        - !Sub '${CURReportPrefixName}/${CURReportName}/${CURReportName}'

  AWSCURReportStatusTable:
    Type: 'AWS::Glue::Table'
    DependsOn: AWSCURDatabase
    Properties:
      DatabaseName: !Ref AWSCURDatabase
      CatalogId: !Ref AWS::AccountId
      TableInput:
        Name: 'cost_and_usage_data_status'
        TableType: 'EXTERNAL_TABLE'
        StorageDescriptor:
          Columns:
            - Name: status
              Type: 'string'
          InputFormat: 'org.apache.hadoop.hive.ql.io.parquet.MapredParquetInputFormat'
          OutputFormat: 'org.apache.hadoop.hive.ql.io.parquet.MapredParquetOutputFormat'
          SerdeInfo:
            SerializationLibrary: 'org.apache.hadoop.hive.ql.io.parquet.serde.ParquetHiveSerDe'
          Location: !If
            - CreateCURReport
            - !Sub 's3://${CURDataBucket}/${CURReportPrefixName}/${CURReport}/cost_and_usage_data_status/'
            - !Sub 's3://${CURDataBucketName}/${CURReportPrefixName}/${CURReportName}/cost_and_usage_data_status/'

  MyAthenaQueryResultsBucket:
    Type: AWS::S3::Bucket
    DeletionPolicy: Retain
    Properties:
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      AccessControl: BucketOwnerFullControl
      OwnershipControls:
        Rules:
          - ObjectOwnership: BucketOwnerEnforced
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      LifecycleConfiguration:
        Rules:
          - Id: DeleteContent
            Status: 'Enabled'
            ExpirationInDays: 7
      VersioningConfiguration:
        Status: Enabled
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: 'W35'
            reason: "Data buckets would generate too much logs"

  MyAthenaWorkGroup:
    Type: AWS::Athena::WorkGroup
    Properties:
      Name: !Ref AWS::StackName
      Description: 'Used for COAST'
      WorkGroupConfiguration:
        EnforceWorkGroupConfiguration: true
        ResultConfiguration:
          EncryptionConfiguration:
            EncryptionOption: SSE_S3
          OutputLocation: !Sub 's3://${MyAthenaQueryResultsBucket}'
          AclConfiguration:
            S3AclOption: BUCKET_OWNER_FULL_CONTROL
      Tags:
        - Key: GrafanaDataSource
          Value: 'true'

  GrafanaWorkspaceRole:
    Type: AWS::IAM::Role
    Properties: 
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
        - Effect: Allow
          Principal:
            Service: 'grafana.amazonaws.com'
          Action: 'sts:AssumeRole'
      Description: 'COAST Grafana Workspace Role'
      ManagedPolicyArns: 
        - 'arn:aws:iam::aws:policy/service-role/AmazonGrafanaAthenaAccess'
      Policies:
        - PolicyName: 'GrafanaAthenaS3Access'
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
                Effect: Allow
                Action:
                  - 's3:GetBucketLocation'
                  - 's3:GetObject'
                  - 's3:ListBucket'
                  - 's3:ListBucketMultipartUploads'
                  - 's3:ListMultipartUploadParts'
                  - 's3:AbortMultipartUpload'
                  - 's3:CreateBucket'
                  - 's3:PutObject'
                  - 's3:PutBucketPublicAccessBlock'
                Resource:
                  - !If
                    - CreateCURReport
                    - !Sub 'arn:aws:s3:::${CURDataBucket}'
                    - !Sub 'arn:aws:s3:::${CURDataBucketName}'
                  - !If
                    - CreateCURReport
                    - !Sub 'arn:aws:s3:::${CURDataBucket}/*'
                    - !Sub 'arn:aws:s3:::${CURDataBucketName}/*'
                  - !Sub 'arn:aws:s3:::${MyAthenaQueryResultsBucket}'
                  - !Sub 'arn:aws:s3:::${MyAthenaQueryResultsBucket}/*'
      Path: /

  GrafanaWorkspace:
    Type: AWS::Grafana::Workspace
    Properties: 
      AccountAccessType: CURRENT_ACCOUNT
      AuthenticationProviders: 
        - AWS_SSO
      DataSources: 
        - CLOUDWATCH
        - ATHENA
      Description: 'COAST Project Workspace'
      GrafanaVersion: '9.4'
      Name: COAST
      NotificationDestinations: 
        - SNS
      PermissionType: SERVICE_MANAGED
      RoleArn: !Ref GrafanaWorkspaceRole

  COASTDataSourceFunctionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - 'sts:AssumeRole'
      Path: /
      Policies:
        - PolicyName: LambdaExecution
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - 'logs:CreateLogGroup'
                  - 'logs:CreateLogStream'
                  - 'logs:PutLogEvents'
                Resource: !Sub 'arn:${AWS::Partition}:logs:*:*:*'
              - Effect: Allow
                Action:
                  - 'sns:Publish'
                Resource: !Ref COASTNotificationsTopic
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AWSGrafanaAccountAdministrator

  COASTDataSourceFunction:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          import cfnresponse
          import boto3
          import urllib3
          import json
          SUCCESS="SUCCESS"
          FAILED="FAILED"
          class CoastGrafanaWorkspace:
              client=boto3.client('grafana')
              http=urllib3.PoolManager()
              def __init__(self,athena_db,athena_region,athena_workgroup,datasource_name,key_name,workspace_id):
                  self.athena_db=athena_db
                  self.athena_region=athena_region
                  self.athena_workgroup=athena_workgroup
                  self.datasource_name=datasource_name
                  self.workspace=self.get_workspace(workspace_id)
                  self.key=self.create_key(key_name)
                  self.common_headers={'Accept':'application/json','Content-Type':'application/json','Authorization':'Bearer '+self.key['key']}
              def get_workspace(self,workspace_id):
                  workspaces=self.client.list_workspaces()
                  for workspace in workspaces['workspaces']:
                      if workspace['id']==workspace_id:
                          return workspace
              def create_key(self,key_name):
                  try:
                      self.client.delete_workspace_api_key(keyName=key_name,workspaceId=self.workspace['id'])
                  except Exception as err:
                      print('Error:'+str(err))
                      pass
                  finally:
                      return self.client.create_workspace_api_key(keyName=key_name,keyRole='ADMIN',secondsToLive=60,workspaceId=self.workspace['id'])
              def delete_datasource(self,id):
                  return self.grafana_api('DELETE','datasources/'+str(id))
              def set_datasource_body(self):
                  body = {'name':self.datasource_name,'type':'grafana-athena-datasource','access':'proxy','url':'','user':'','database':'','basicAuth':False,'isDefault':False,'jsonData':{'authType':'ec2_iam_role','catalog':'AwsDataCatalog','database':self.athena_db,'defaultRegion':self.athena_region,'provisionedBy':'COAST','workgroup':self.athena_workgroup},'readOnly':False}
                  return bytes(json.dumps(body),encoding='utf-8')
              def create_datasource(self):
                  return self.grafana_api('POST','datasources',self.set_datasource_body())
              def update_datasource(self,id):
                    return self.grafana_api('PUT','datasources/'+str(id),self.set_datasource_body())
              def grafana_api(self,method,path,body=None):
                  url='https://'+self.workspace['endpoint']+'/api/'+path
                  headers={'Accept':'application/json','Content-Type':'application/json','Authorization':'Bearer '+self.key['key']}
                  print(method + ' ' + url + ' ' + str(body))
                  res=self.http.request(method,url,headers=headers,body=body)
                  return res
          def lambda_handler(event,context):
              print(json.dumps(event,indent=4))
              response_data={'Data': None}
              try:
                  id=event['PhysicalResourceId'] if 'PhysicalResourceId' in event else '0'
                  ws=CoastGrafanaWorkspace(athena_db=event['ResourceProperties']['AthenaDB'],athena_region=event['ResourceProperties']['AthenaRegion'],athena_workgroup=event['ResourceProperties']['AthenaWorkgroup'],datasource_name=event['ResourceProperties']['DataSource'],key_name=event['ResourceProperties']['GrafanaKey'],workspace_id=event['ResourceProperties']['GrafanaWorkspace'])
                  if event['RequestType']=='Create':
                      res=ws.create_datasource()
                  elif event['RequestType']=='Update':
                      if int(id)>0:
                        res=ws.update_datasource(id)
                      else:
                        res=ws.create_datasource()
                  elif event['RequestType']=='Delete':
                      res=ws.delete_datasource(id)
                  print('Status: '+str(res.status))
                  print(res.data)
                  datasource_id=str(json.loads(res.data)['id']) 
                  if res.status==200:
                    cfnresponse.send(event,context,cfnresponse.SUCCESS,response_data,datasource_id)
                  else:
                    cfnresponse.send(event,context,cfnresponse.FAILED,response_data,datasource_id)
              except Exception as err:
                  print('Error:'+str(err))
                  cfnresponse.send(event,context,cfnresponse.FAILED,response_data,'0')

      Role: !GetAtt COASTDataSourceFunctionRole.Arn
      Handler: 'index.lambda_handler'
      Timeout: 30
      Runtime: python3.10
      ReservedConcurrentExecutions: 1

  GrafanaDatasource:
    Type: 'Custom::GrafanaDatasource'
    Properties:
      ServiceToken: !GetAtt COASTDataSourceFunction.Arn
      AthenaDB: !Ref AWSCURDatabase
      AthenaRegion: !Ref AWS::Region
      AthenaWorkgroup: !Ref MyAthenaWorkGroup
      DataSource: !Ref AWS::StackName
      GrafanaKey: !Ref AWS::StackName
      GrafanaWorkspace: !Ref GrafanaWorkspace

  COASTDashboardFunction:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          import cfnresponse
          import boto3
          import urllib3
          import json
          SUCCESS="SUCCESS"
          FAILED="FAILED"
          class CoastGrafanaDashboard:
              client=boto3.client('grafana')
              http=urllib3.PoolManager()
              def __init__(self,dashboard_name,dashboard_url,key_name,workspace_id):
                  self.dashboard_name=dashboard_name
                  self.dashboard_url=dashboard_url
                  self.workspace=self.get_workspace(workspace_id)
                  self.key=self.create_key(key_name)
                  self.common_headers={'Accept':'application/json','Content-Type':'application/json','Authorization':'Bearer '+self.key['key']}
              def get_workspace(self,workspace_id):
                  workspaces=self.client.list_workspaces()
                  for workspace in workspaces['workspaces']:
                      if workspace['id']==workspace_id:
                          return workspace
              def create_key(self,key_name):
                  try:
                      self.client.delete_workspace_api_key(keyName=key_name,workspaceId=self.workspace['id'])
                  except Exception as err:
                      print('Error:'+str(err))
                      pass
                  finally:
                      return self.client.create_workspace_api_key(keyName=key_name,keyRole='ADMIN',secondsToLive=60,workspaceId=self.workspace['id'])
              def grafana_api(self,method,path,body=None):
                  url='https://'+self.workspace['endpoint']+'/api/'+path
                  print(method+' '+url)
                  return self.http.request(method,url,headers=self.common_headers,body=body)
              def set_dashboard_body(self):
                  body={}
                  body['dashboard']=json.loads(self.http.request('GET',self.dashboard_url).data)
                  body['dashboard']['id']=None
                  body['overwrite']=True
                  return bytes(json.dumps(body),encoding='utf-8')
              def create_dashboard(self):
                  return self.grafana_api('POST','dashboards/db',self.set_dashboard_body())
              def delete_dashboard(self,uid):
                  return self.grafana_api('DELETE','dashboards/uid/'+uid)
          def lambda_handler(event,context):
              print(json.dumps(event,indent=4))
              response_data={'Data': None}
              try:
                  uid=event['PhysicalResourceId'] if 'PhysicalResourceId' in event else '0'
                  ws=CoastGrafanaDashboard(dashboard_name=event['ResourceProperties']['DashboardName'],dashboard_url=event['ResourceProperties']['DashboardURL'],key_name=event['ResourceProperties']['GrafanaKey'],workspace_id=event['ResourceProperties']['GrafanaWorkspace'])
                  if event['RequestType']=='Create':
                      res=ws.create_dashboard()
                  elif event['RequestType']=='Update':
                      ws.delete_dashboard(uid)
                      res=ws.create_dashboard()
                  elif event['RequestType']=='Delete':
                      res=ws.delete_dashboard(uid)
                  print('Status: '+str(res.status))
                  print(res.data)
                  if 'uid' in json.loads(res.data):
                      dashboard_uid=str(json.loads(res.data)['uid']) 
                  else:
                      dashboard_uid='0'
                  if res.status==200 or (event['RequestType']=='Delete' and uid=='0'):
                      cfnresponse.send(event,context,cfnresponse.SUCCESS,response_data,dashboard_uid)
                  else:
                      cfnresponse.send(event,context,cfnresponse.FAILED,response_data,dashboard_uid)
              except Exception as err:
                  print('Error:'+str(err))
                  cfnresponse.send(event,context,cfnresponse.FAILED,response_data,'0')

      Role: !GetAtt COASTDataSourceFunctionRole.Arn
      Handler: 'index.lambda_handler'
      Timeout: 30
      Runtime: python3.10
      ReservedConcurrentExecutions: 1

  COASTDashboard:
    Type: 'Custom::GrafanaDashboard'
    Properties:
      ServiceToken: !GetAtt COASTDashboardFunction.Arn
      DashboardName: !Sub 'COAST-${AWS::StackName}'
      DashboardURL: !Ref GrafanaDashboardTemplateURL
      DashboardDatasource: !Ref GrafanaDatasource
      GrafanaKey: !Ref AWS::StackName
      GrafanaWorkspace: !Ref GrafanaWorkspace
